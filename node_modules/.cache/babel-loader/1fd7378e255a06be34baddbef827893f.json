{"ast":null,"code":"import { appendClasses } from '../appendClasses';\nimport { createResolvedMap } from '../createClassResolver';\nexport var makeClasses = function (classes) {\n  // This is in creation time, so this will happen once per css file.\n  var _a = createResolvedMap(classes),\n      slots = _a.slots,\n      modifiers = _a.modifiers,\n      enums = _a.enums;\n\n  return function useClasses(state) {\n    var _a;\n\n    var modifierClasses = '';\n    var enumClasses = '';\n\n    for (var _i = 0, _b = Object.keys(modifiers); _i < _b.length; _i++) {\n      var modifierName = _b[_i];\n\n      if (state[modifierName]) {\n        modifierClasses = appendClasses(modifierClasses, modifiers[modifierName]);\n      }\n    }\n\n    for (var _c = 0, _d = Object.keys(enums); _c < _d.length; _c++) {\n      var enumName = _d[_c];\n      var enumValues = enums[enumName]; // if we have a class which matches the enumName and current state value, add it.\n\n      if (enumValues[state[enumName]] !== undefined) {\n        enumClasses = appendClasses(enumClasses, enumValues[state[enumName]]);\n      }\n    }\n\n    state.className = appendClasses(state.className, slots.root, modifierClasses, enumClasses);\n\n    for (var _e = 0, _f = Object.keys(slots); _e < _f.length; _e++) {\n      var slotName = _f[_e];\n\n      if (slotName !== 'root') {\n        state[slotName] = state[slotName] || {};\n        state[slotName].className = appendClasses((_a = state[slotName]) === null || _a === void 0 ? void 0 : _a.className, slots[slotName]);\n      }\n    }\n  };\n};","map":{"version":3,"sources":["next/makeClasses.ts"],"names":[],"mappings":"AACA,SAAS,aAAT,QAA8B,kBAA9B;AACA,SAAS,iBAAT,QAAkC,wBAAlC;AAEA,OAAO,IAAM,WAAW,GAAG,UAAC,OAAD,EAAyB;AAClD;AACM,MAAA,EAAA,GAAA,iBAAA,CAAA,OAAA,CAAA;AAAA,MAAE,KAAA,GAAA,EAAA,CAAA,KAAF;AAAA,MAAS,SAAA,GAAA,EAAA,CAAA,SAAT;AAAA,MAAoB,KAAA,GAAA,EAAA,CAAA,KAApB;;AAEN,SAAO,SAAS,UAAT,CAAoB,KAApB,EAA4C;;;AACjD,QAAI,eAAe,GAAG,EAAtB;AACA,QAAI,WAAW,GAAG,EAAlB;;AAEA,SAA2B,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,MAAM,CAAC,IAAP,CAAY,SAAZ,CAA3B,EAA2B,EAAA,GAAA,EAAA,CAAA,MAA3B,EAA2B,EAAA,EAA3B,EAAmD;AAA9C,UAAM,YAAY,GAAA,EAAA,CAAA,EAAA,CAAlB;;AACH,UAAI,KAAK,CAAC,YAAD,CAAT,EAAyB;AACvB,QAAA,eAAe,GAAG,aAAa,CAAC,eAAD,EAAkB,SAAS,CAAC,YAAD,CAA3B,CAA/B;AACD;AACF;;AAED,SAAuB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,MAAM,CAAC,IAAP,CAAY,KAAZ,CAAvB,EAAuB,EAAA,GAAA,EAAA,CAAA,MAAvB,EAAuB,EAAA,EAAvB,EAA2C;AAAtC,UAAM,QAAQ,GAAA,EAAA,CAAA,EAAA,CAAd;AACH,UAAM,UAAU,GAAG,KAAK,CAAC,QAAD,CAAxB,CADyC,CAEzC;;AACA,UAAI,UAAU,CAAC,KAAK,CAAC,QAAD,CAAN,CAAV,KAAgC,SAApC,EAA+C;AAC7C,QAAA,WAAW,GAAG,aAAa,CAAC,WAAD,EAAc,UAAU,CAAC,KAAK,CAAC,QAAD,CAAN,CAAxB,CAA3B;AACD;AACF;;AAED,IAAA,KAAK,CAAC,SAAN,GAAkB,aAAa,CAAC,KAAK,CAAC,SAAP,EAAkB,KAAK,CAAC,IAAxB,EAA8B,eAA9B,EAA+C,WAA/C,CAA/B;;AAEA,SAAuB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,MAAM,CAAC,IAAP,CAAY,KAAZ,CAAvB,EAAuB,EAAA,GAAA,EAAA,CAAA,MAAvB,EAAuB,EAAA,EAAvB,EAA2C;AAAtC,UAAM,QAAQ,GAAA,EAAA,CAAA,EAAA,CAAd;;AACH,UAAI,QAAQ,KAAK,MAAjB,EAAyB;AACvB,QAAA,KAAK,CAAC,QAAD,CAAL,GAAkB,KAAK,CAAC,QAAD,CAAL,IAAmB,EAArC;AACA,QAAA,KAAK,CAAC,QAAD,CAAL,CAAgB,SAAhB,GAA4B,aAAa,CAAA,CAAA,EAAA,GAAC,KAAK,CAAC,QAAD,CAAN,MAAgB,IAAhB,IAAgB,EAAA,KAAA,KAAA,CAAhB,GAAgB,KAAA,CAAhB,GAAgB,EAAA,CAAE,SAAlB,EAA6B,KAAK,CAAC,QAAD,CAAlC,CAAzC;AACD;AACF;AACF,GA1BD;AA2BD,CA/BM","sourcesContent":["import { GenericDictionary, ClassDictionary } from './types';\nimport { appendClasses } from '../appendClasses';\nimport { createResolvedMap } from '../createClassResolver';\n\nexport const makeClasses = (classes: ClassDictionary) => {\n  // This is in creation time, so this will happen once per css file.\n  const { slots, modifiers, enums } = createResolvedMap(classes);\n\n  return function useClasses(state: GenericDictionary) {\n    let modifierClasses = '';\n    let enumClasses = '';\n\n    for (const modifierName of Object.keys(modifiers)) {\n      if (state[modifierName]) {\n        modifierClasses = appendClasses(modifierClasses, modifiers[modifierName]);\n      }\n    }\n\n    for (const enumName of Object.keys(enums)) {\n      const enumValues = enums[enumName];\n      // if we have a class which matches the enumName and current state value, add it.\n      if (enumValues[state[enumName]] !== undefined) {\n        enumClasses = appendClasses(enumClasses, enumValues[state[enumName]]);\n      }\n    }\n\n    state.className = appendClasses(state.className, slots.root, modifierClasses, enumClasses);\n\n    for (const slotName of Object.keys(slots)) {\n      if (slotName !== 'root') {\n        state[slotName] = state[slotName] || {};\n        state[slotName].className = appendClasses(state[slotName]?.className, slots[slotName]);\n      }\n    }\n  };\n};\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}