{"ast":null,"code":"import * as React from 'react';\nimport { getNativeElementProps, omit } from '@uifabric/utilities';\nimport { nullRender } from './nullRender';\n/**\r\n * Given the state and an array of slot names, will break out `slots` and `slotProps`\r\n * collections.\r\n *\r\n * The root is always derived from the `as` prop.\r\n *\r\n * Slots will render as null if they are rendered as primitives with undefined children.\r\n *\r\n * The slotProps will always omit the `as` prop within them, and for slots that are string\r\n * primitives, the props will be filtered according the the slot type. For example, if the\r\n * slot is rendered `as: 'a'`, the props will be filtered for acceptable anchor props.\r\n *\r\n * @param state - State including slot definitions\r\n * @param slotNames - Name of which props are slots\r\n * @returns An object containing the `slots` map and `slotProps` map.\r\n */\n\nexport var getSlots = function (state, slotNames) {\n  var slots = {\n    root: state.as || 'div'\n  };\n  var slotProps = {\n    root: typeof state.as === 'string' ? getNativeElementProps(state.as, state) : omit(state, ['as'])\n  };\n\n  if (slotNames) {\n    for (var _i = 0, slotNames_1 = slotNames; _i < slotNames_1.length; _i++) {\n      var name_1 = slotNames_1[_i];\n      var slotDefinition = state[name_1] || {};\n      var _a = slotDefinition.as,\n          slotAs = _a === void 0 ? 'span' : _a,\n          children = slotDefinition.children;\n      var isSlotPrimitive = typeof slotAs === 'string';\n      var isSlotEmpty = isSlotPrimitive && slotDefinition.children === undefined;\n      slots[name_1] = isSlotEmpty ? nullRender : slotAs;\n\n      if (typeof children === 'function') {\n        slotProps[name_1] = {\n          children: children(slots[name_1], omit(slotDefinition, ['as', 'children']))\n        };\n        slots[name_1] = React.Fragment;\n      } else if (slots[name_1] !== nullRender) {\n        slotProps[name_1] = isSlotPrimitive ? getNativeElementProps(slotAs, slotDefinition) : omit(slotDefinition, ['as']);\n      }\n    }\n  }\n\n  return {\n    slots: slots,\n    slotProps: slotProps\n  };\n};","map":{"version":3,"sources":["next/getSlots.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,KAAZ,MAAuB,OAAvB;AACA,SAAS,qBAAT,EAAgC,IAAhC,QAA4C,qBAA5C;AAEA,SAAS,UAAT,QAA2B,cAA3B;AAEA;;;;;;;;;;;;;;;AAeG;;AACH,OAAO,IAAM,QAAQ,GAAG,UAAC,KAAD,EAA2B,SAA3B,EAA2D;AACjF,MAAM,KAAK,GAAsB;AAC/B,IAAA,IAAI,EAAE,KAAK,CAAC,EAAN,IAAY;AADa,GAAjC;AAGA,MAAM,SAAS,GAAsB;AACnC,IAAA,IAAI,EAAE,OAAO,KAAK,CAAC,EAAb,KAAoB,QAApB,GAA+B,qBAAqB,CAAC,KAAK,CAAC,EAAP,EAAW,KAAX,CAApD,GAAwE,IAAI,CAAC,KAAD,EAAQ,CAAC,IAAD,CAAR;AAD/C,GAArC;;AAIA,MAAI,SAAJ,EAAe;AACb,SAAmB,IAAA,EAAA,GAAA,CAAA,EAAA,WAAA,GAAA,SAAnB,EAAmB,EAAA,GAAA,WAAA,CAAA,MAAnB,EAAmB,EAAA,EAAnB,EAA8B;AAAzB,UAAM,MAAI,GAAA,WAAA,CAAA,EAAA,CAAV;AACH,UAAM,cAAc,GAAG,KAAK,CAAC,MAAD,CAAL,IAAe,EAAtC;AACQ,UAAA,EAAA,GAAA,cAAA,CAAA,EAAA;AAAA,UAAA,MAAA,GAAA,EAAA,KAAA,KAAA,CAAA,GAAA,MAAA,GAAA,EAAA;AAAA,UAAqB,QAAA,GAAA,cAAA,CAAA,QAArB;AACR,UAAM,eAAe,GAAG,OAAO,MAAP,KAAkB,QAA1C;AACA,UAAM,WAAW,GAAG,eAAe,IAAI,cAAc,CAAC,QAAf,KAA4B,SAAnE;AAEA,MAAA,KAAK,CAAC,MAAD,CAAL,GAAc,WAAW,GAAG,UAAH,GAAgB,MAAzC;;AAEA,UAAI,OAAO,QAAP,KAAoB,UAAxB,EAAoC;AAClC,QAAA,SAAS,CAAC,MAAD,CAAT,GAAkB;AAChB,UAAA,QAAQ,EAAE,QAAQ,CAAC,KAAK,CAAC,MAAD,CAAN,EAAc,IAAI,CAAC,cAAD,EAAiB,CAAC,IAAD,EAAO,UAAP,CAAjB,CAAlB;AADF,SAAlB;AAGA,QAAA,KAAK,CAAC,MAAD,CAAL,GAAc,KAAK,CAAC,QAApB;AACD,OALD,MAKO,IAAI,KAAK,CAAC,MAAD,CAAL,KAAgB,UAApB,EAAgC;AACrC,QAAA,SAAS,CAAC,MAAD,CAAT,GAAkB,eAAe,GAC7B,qBAAqB,CAAC,MAAD,EAAS,cAAT,CADQ,GAE7B,IAAI,CAAC,cAAD,EAAiB,CAAC,IAAD,CAAjB,CAFR;AAGD;AACF;AACF;;AAED,SAAO;AAAE,IAAA,KAAK,EAAA,KAAP;AAAS,IAAA,SAAS,EAAA;AAAlB,GAAP;AACD,CA/BM","sourcesContent":["import * as React from 'react';\nimport { getNativeElementProps, omit } from '@uifabric/utilities';\nimport { GenericDictionary } from './types';\nimport { nullRender } from './nullRender';\n\n/**\n * Given the state and an array of slot names, will break out `slots` and `slotProps`\n * collections.\n *\n * The root is always derived from the `as` prop.\n *\n * Slots will render as null if they are rendered as primitives with undefined children.\n *\n * The slotProps will always omit the `as` prop within them, and for slots that are string\n * primitives, the props will be filtered according the the slot type. For example, if the\n * slot is rendered `as: 'a'`, the props will be filtered for acceptable anchor props.\n *\n * @param state - State including slot definitions\n * @param slotNames - Name of which props are slots\n * @returns An object containing the `slots` map and `slotProps` map.\n */\nexport const getSlots = (state: GenericDictionary, slotNames?: string[] | undefined) => {\n  const slots: GenericDictionary = {\n    root: state.as || 'div',\n  };\n  const slotProps: GenericDictionary = {\n    root: typeof state.as === 'string' ? getNativeElementProps(state.as, state) : omit(state, ['as']),\n  };\n\n  if (slotNames) {\n    for (const name of slotNames) {\n      const slotDefinition = state[name] || {};\n      const { as: slotAs = 'span', children } = slotDefinition;\n      const isSlotPrimitive = typeof slotAs === 'string';\n      const isSlotEmpty = isSlotPrimitive && slotDefinition.children === undefined;\n\n      slots[name] = isSlotEmpty ? nullRender : slotAs;\n\n      if (typeof children === 'function') {\n        slotProps[name] = {\n          children: children(slots[name], omit(slotDefinition, ['as', 'children'])),\n        };\n        slots[name] = React.Fragment;\n      } else if (slots[name] !== nullRender) {\n        slotProps[name] = isSlotPrimitive\n          ? getNativeElementProps(slotAs, slotDefinition)\n          : omit(slotDefinition, ['as']);\n      }\n    }\n  }\n\n  return { slots, slotProps };\n};\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}