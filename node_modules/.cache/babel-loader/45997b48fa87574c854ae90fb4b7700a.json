{"ast":null,"code":"/**\r\n * The `applyClasses` takes in a mutable state and a class map and, given the class map\r\n * follows the a naming convention described below, auto-applies classes to the appropriate places\r\n * in the state.\r\n *\r\n * Usage:\r\n *\r\n * ```tsx\r\n * const useButtonClasses = makeClasses(theme => {\r\n *   root: { ... },\r\n *   _primary: { ... },\r\n *   _size_small: { ... }\r\n * });\r\n * ```\r\n *\r\n * The class naming convention is broken down as follows:\r\n *\r\n * * No underscores - a slot class name. (E.g. \"root\", \"icon\", etc)\r\n * * Prefixed with underscore - a modifier. (E.g. \"_primary\", \"_fluid\")\r\n * * Contains 2 underscores - a name/value matcher. (E.g. \"_size_small\")\r\n *\r\n * Modifier classnames are added to the root className when the state contains a truthy value\r\n * of the same name. For example, when the primary flag is present, the \"_primary\" modifier\r\n * class will be appended to the root className prop.\r\n *\r\n * Enum classnames are also added to the root className when teh state contains an enum value\r\n * which matches the value in the className. for example, when the `size` enum value is `small`,\r\n * the \"_size_small\" enum class will be appended to the root className prop.\r\n */\nexport var applyClasses = function (state, classMap) {\n  for (var _i = 0, _a = Object.keys(classMap); _i < _a.length; _i++) {\n    var key = _a[_i];\n    var value = classMap[key];\n    var parts = key.split('_');\n\n    switch (parts.length) {\n      case 1:\n        if (key === 'root') {\n          _setClass(state, value);\n        } else if (key !== 'subComponentStyles') {\n          // The subComponentStyles check is an unfortunate workaround to avoid breaking partners.\n          _setClass(state, value, key);\n        }\n\n        break;\n\n      case 2:\n        var modifierName = parts[1]; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n        if (state[modifierName] || state.variant === modifierName) {\n          _setClass(state, value);\n        }\n\n        break;\n\n      case 3:\n        var enumName = parts[1];\n        var enumValue = parts[2]; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n        if (state[enumName] === enumValue) {\n          _setClass(state, value);\n        }\n\n        break;\n    }\n  }\n}; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nfunction _setClass(state, className, slot) {\n  var currentSlot = slot ? state[slot] = state[slot] || {} : state;\n\n  if (currentSlot.className) {\n    currentSlot.className += ' ' + className;\n  } else {\n    currentSlot.className = className;\n  }\n}","map":{"version":3,"sources":["applyClasses.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BG;AACH,OAAO,IAAM,YAAY,GAAG,UAAoB,KAApB,EAAmC,QAAnC,EAAmE;AAC7F,OAAkB,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,MAAM,CAAC,IAAP,CAAY,QAAZ,CAAlB,EAAkB,EAAA,GAAA,EAAA,CAAA,MAAlB,EAAkB,EAAA,EAAlB,EAAyC;AAApC,QAAM,GAAG,GAAA,EAAA,CAAA,EAAA,CAAT;AACH,QAAM,KAAK,GAAG,QAAQ,CAAC,GAAD,CAAtB;AACA,QAAM,KAAK,GAAG,GAAG,CAAC,KAAJ,CAAU,GAAV,CAAd;;AAEA,YAAQ,KAAK,CAAC,MAAd;AACE,WAAK,CAAL;AACE,YAAI,GAAG,KAAK,MAAZ,EAAoB;AAClB,UAAA,SAAS,CAAC,KAAD,EAAQ,KAAR,CAAT;AACD,SAFD,MAEO,IAAI,GAAG,KAAK,oBAAZ,EAAkC;AACvC;AACA,UAAA,SAAS,CAAC,KAAD,EAAQ,KAAR,EAAe,GAAf,CAAT;AACD;;AACD;;AAEF,WAAK,CAAL;AACE,YAAM,YAAY,GAAG,KAAK,CAAC,CAAD,CAA1B,CADF,CAGE;;AACA,YAAK,KAAa,CAAC,YAAD,CAAb,IAAgC,KAAa,CAAC,OAAd,KAA0B,YAA/D,EAA6E;AAC3E,UAAA,SAAS,CAAC,KAAD,EAAQ,KAAR,CAAT;AACD;;AACD;;AAEF,WAAK,CAAL;AACE,YAAM,QAAQ,GAAG,KAAK,CAAC,CAAD,CAAtB;AACA,YAAM,SAAS,GAAG,KAAK,CAAC,CAAD,CAAvB,CAFF,CAIE;;AACA,YAAK,KAAa,CAAC,QAAD,CAAb,KAA4B,SAAjC,EAA4C;AAC1C,UAAA,SAAS,CAAC,KAAD,EAAQ,KAAR,CAAT;AACD;;AACD;AA3BJ;AA6BD;AACF,CAnCM,C,CAqCP;;AACA,SAAS,SAAT,CAAmB,KAAnB,EAA+C,SAA/C,EAAkE,IAAlE,EAA+E;AAC7E,MAAM,WAAW,GAAG,IAAI,GAAI,KAAK,CAAC,IAAD,CAAL,GAAc,KAAK,CAAC,IAAD,CAAL,IAAe,EAAjC,GAAuC,KAA/D;;AAEA,MAAI,WAAW,CAAC,SAAhB,EAA2B;AACzB,IAAA,WAAW,CAAC,SAAZ,IAAyB,MAAM,SAA/B;AACD,GAFD,MAEO;AACL,IAAA,WAAW,CAAC,SAAZ,GAAwB,SAAxB;AACD;AACF","sourcesContent":["/**\n * The `applyClasses` takes in a mutable state and a class map and, given the class map\n * follows the a naming convention described below, auto-applies classes to the appropriate places\n * in the state.\n *\n * Usage:\n *\n * ```tsx\n * const useButtonClasses = makeClasses(theme => {\n *   root: { ... },\n *   _primary: { ... },\n *   _size_small: { ... }\n * });\n * ```\n *\n * The class naming convention is broken down as follows:\n *\n * * No underscores - a slot class name. (E.g. \"root\", \"icon\", etc)\n * * Prefixed with underscore - a modifier. (E.g. \"_primary\", \"_fluid\")\n * * Contains 2 underscores - a name/value matcher. (E.g. \"_size_small\")\n *\n * Modifier classnames are added to the root className when the state contains a truthy value\n * of the same name. For example, when the primary flag is present, the \"_primary\" modifier\n * class will be appended to the root className prop.\n *\n * Enum classnames are also added to the root className when teh state contains an enum value\n * which matches the value in the className. for example, when the `size` enum value is `small`,\n * the \"_size_small\" enum class will be appended to the root className prop.\n */\nexport const applyClasses = <TState extends {}>(state: TState, classMap: Record<string, string>) => {\n  for (const key of Object.keys(classMap)) {\n    const value = classMap[key];\n    const parts = key.split('_');\n\n    switch (parts.length) {\n      case 1:\n        if (key === 'root') {\n          _setClass(state, value);\n        } else if (key !== 'subComponentStyles') {\n          // The subComponentStyles check is an unfortunate workaround to avoid breaking partners.\n          _setClass(state, value, key);\n        }\n        break;\n\n      case 2:\n        const modifierName = parts[1];\n\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        if ((state as any)[modifierName] || (state as any).variant === modifierName) {\n          _setClass(state, value);\n        }\n        break;\n\n      case 3:\n        const enumName = parts[1];\n        const enumValue = parts[2];\n\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        if ((state as any)[enumName] === enumValue) {\n          _setClass(state, value);\n        }\n        break;\n    }\n  }\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _setClass(state: Record<string, any>, className: string, slot?: string) {\n  const currentSlot = slot ? (state[slot] = state[slot] || {}) : state;\n\n  if (currentSlot.className) {\n    currentSlot.className += ' ' + className;\n  } else {\n    currentSlot.className = className;\n  }\n}\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}