{"ast":null,"code":"/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { tokensToStyleObject } from './tokensToStyleObject';\nimport { makeClasses } from './makeClasses';\n/**\r\n * Calls a function with the argument, or returns the given object.\r\n * @param objOrFunc - Function or object.\r\n * @param argument - Argument to pass if a function is provided.\r\n */\n\nvar callOrReturn = function (objOrFunc, argument) {\n  return typeof objOrFunc === 'function' ? objOrFunc(argument) : objOrFunc;\n};\n\nvar processVariants = function (variants, theme, name, prefix) {\n  var result = {};\n\n  if (variants) {\n    variants = callOrReturn(variants, theme);\n\n    for (var _i = 0, _a = Object.keys(variants); _i < _a.length; _i++) {\n      var variantName = _a[_i];\n      var modifierName = variantName === 'root' ? variantName : '_' + variantName;\n      var rule = result[modifierName] = tokensToStyleObject(variants[variantName], prefix); // The display name should be tied to the unique theme object, causing the\n      // renderer to treat scoped themes as sandboxed css scopes.\n\n      if (name) {\n        rule.displayName = \"\" + name + (theme.id || '');\n\n        if (variantName !== 'root') {\n          rule.displayName += \"--\" + variantName;\n        }\n      }\n    }\n  }\n\n  return result;\n};\n/**\r\n * Hook factory for creating a `use*Variants` helper. Variants represent a configuration of\r\n * token values mapped to modifiers on the component. A variant can also be referenced using\r\n * a variant string. Variants can be overridden through the theme of the component.\r\n */\n\n\nexport var makeVariantClasses = function (options) {\n  var styles = options.styles,\n      variants = options.variants,\n      name = options.name,\n      prefix = options.prefix; // This function will only be called when styles have not been evaluated for this set for\n  // the particular theme/window/direction combo.\n\n  var styleFunction = function (theme) {\n    var _a, _b, _c;\n\n    var themeVariants = name ? (_c = (_b = (_a = theme) === null || _a === void 0 ? void 0 : _a.components) === null || _b === void 0 ? void 0 : _b[name]) === null || _c === void 0 ? void 0 : _c.variants : undefined;\n    return [callOrReturn(styles, theme), processVariants(variants, theme, name, prefix), processVariants(themeVariants, theme, name, prefix)];\n  };\n\n  return makeClasses(styleFunction);\n};","map":{"version":3,"sources":["makeVariantClasses.ts"],"names":[],"mappings":"AAAA;AACA,SAAS,mBAAT,QAAoC,uBAApC;AAGA,SAAS,WAAT,QAA4B,eAA5B;AAEA;;;;AAIG;;AACH,IAAM,YAAY,GAAG,UAAC,SAAD,EAAiB,QAAjB,EAA8B;AACjD,SAAA,OAAO,SAAP,KAAqB,UAArB,GAAkC,SAAS,CAAC,QAAD,CAA3C,GAAwD,SAAxD;AAAiE,CADnE;;AAGA,IAAM,eAAe,GAAG,UAAC,QAAD,EAAiC,KAAjC,EAA+C,IAA/C,EAA8D,MAA9D,EAA6E;AACnG,MAAM,MAAM,GAA2B,EAAvC;;AAEA,MAAI,QAAJ,EAAc;AACZ,IAAA,QAAQ,GAAG,YAAY,CAAC,QAAD,EAAW,KAAX,CAAvB;;AAEA,SAA0B,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,MAAM,CAAC,IAAP,CAAY,QAAZ,CAA1B,EAA0B,EAAA,GAAA,EAAA,CAAA,MAA1B,EAA0B,EAAA,EAA1B,EAAkD;AAA7C,UAAM,WAAW,GAAA,EAAA,CAAA,EAAA,CAAjB;AACH,UAAM,YAAY,GAAG,WAAW,KAAK,MAAhB,GAAyB,WAAzB,GAAuC,MAAM,WAAlE;AAEA,UAAM,IAAI,GAAS,MAAM,CAAC,YAAD,CAAN,GAAuB,mBAAmB,CAAC,QAAS,CAAC,WAAD,CAAV,EAAyB,MAAzB,CAA7D,CAHgD,CAKhD;AACA;;AACA,UAAI,IAAJ,EAAU;AACR,QAAA,IAAI,CAAC,WAAL,GAAmB,KAAG,IAAH,IAAU,KAAK,CAAC,EAAN,IAAY,EAAtB,CAAnB;;AACA,YAAI,WAAW,KAAK,MAApB,EAA4B;AAC1B,UAAA,IAAI,CAAC,WAAL,IAAoB,OAAK,WAAzB;AACD;AACF;AACF;AACF;;AAED,SAAO,MAAP;AACD,CAvBD;AAmDA;;;;AAIG;;;AACH,OAAO,IAAM,kBAAkB,GAAG,UAChC,OADgC,EACa;AAErC,MAAA,MAAA,GAAA,OAAA,CAAA,MAAA;AAAA,MAAQ,QAAA,GAAA,OAAA,CAAA,QAAR;AAAA,MAAkB,IAAA,GAAA,OAAA,CAAA,IAAlB;AAAA,MAAwB,MAAA,GAAA,OAAA,CAAA,MAAxB,CAFqC,CAI7C;AACA;;AACA,MAAM,aAAa,GAA6B,UAAC,KAAD,EAAa;;;AAC3D,QAAM,aAAa,GAAG,IAAI,GAAE,CAAA,EAAA,GAAA,CAAA,EAAA,GAAA,CAAA,EAAA,GAAC,KAAD,MAAM,IAAN,IAAM,EAAA,KAAA,KAAA,CAAN,GAAM,KAAA,CAAN,GAAM,EAAA,CAAE,UAAR,MAAkB,IAAlB,IAAkB,EAAA,KAAA,KAAA,CAAlB,GAAkB,KAAA,CAAlB,GAAkB,EAAA,CAAG,IAAH,CAAlB,MAAyB,IAAzB,IAAyB,EAAA,KAAA,KAAA,CAAzB,GAAyB,KAAA,CAAzB,GAAyB,EAAA,CAAG,QAA9B,GAAyC,SAAnE;AAEA,WAAO,CACL,YAAY,CAAC,MAAD,EAAS,KAAT,CADP,EAEL,eAAe,CAAC,QAAD,EAAW,KAAX,EAAkB,IAAlB,EAAwB,MAAxB,CAFV,EAGL,eAAe,CAAC,aAAD,EAAgB,KAAhB,EAAuB,IAAvB,EAA6B,MAA7B,CAHV,CAAP;AAKD,GARD;;AAUA,SAAO,WAAW,CAAS,aAAT,CAAlB;AACD,CAlBM","sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { tokensToStyleObject } from './tokensToStyleObject';\nimport { Variants, Theme } from '@fluentui/theme';\nimport { IStyle } from '@uifabric/merge-styles';\nimport { makeClasses } from './makeClasses';\n\n/**\n * Calls a function with the argument, or returns the given object.\n * @param objOrFunc - Function or object.\n * @param argument - Argument to pass if a function is provided.\n */\nconst callOrReturn = (objOrFunc: any, argument: any) =>\n  typeof objOrFunc === 'function' ? objOrFunc(argument) : objOrFunc;\n\nconst processVariants = (variants: Variants | undefined, theme: Theme, name?: string, prefix?: string) => {\n  const result: Record<string, IStyle> = {};\n\n  if (variants) {\n    variants = callOrReturn(variants, theme);\n\n    for (const variantName of Object.keys(variants!)) {\n      const modifierName = variantName === 'root' ? variantName : '_' + variantName;\n\n      const rule: any = (result[modifierName] = tokensToStyleObject(variants![variantName], prefix) as IStyle);\n\n      // The display name should be tied to the unique theme object, causing the\n      // renderer to treat scoped themes as sandboxed css scopes.\n      if (name) {\n        rule.displayName = `${name}${theme.id || ''}`;\n        if (variantName !== 'root') {\n          rule.displayName += `--${variantName}`;\n        }\n      }\n    }\n  }\n\n  return result;\n};\n\n/**\n * Options for makeVariantClasses.\n */\nexport type MakeVariantClassesOptions<TVariants = Variants> = {\n  /**\n   * Name of the component to use for fetching variants from the theme.\n   */\n  name?: string;\n\n  /**\n   * Prefix for css variables within the variants.\n   */\n  prefix?: string;\n\n  /**\n   * Styles for the component.\n   */\n  styles?: Record<string, IStyle> | ((theme: Theme) => Record<string, IStyle>);\n\n  /**\n   * Variants for the styles. A variant defines token values when a particular prop is present, or the\n   * variant prop matches.\n   */\n  variants?: TVariants | ((theme: Theme) => TVariants);\n};\n\n/**\n * Hook factory for creating a `use*Variants` helper. Variants represent a configuration of\n * token values mapped to modifiers on the component. A variant can also be referenced using\n * a variant string. Variants can be overridden through the theme of the component.\n */\nexport const makeVariantClasses = <TState = {}, TVariants = Variants>(\n  options: MakeVariantClassesOptions<TVariants>,\n) => {\n  const { styles, variants, name, prefix } = options;\n\n  // This function will only be called when styles have not been evaluated for this set for\n  // the particular theme/window/direction combo.\n  const styleFunction: (theme: Theme) => IStyle = (theme: Theme) => {\n    const themeVariants = name ? theme?.components?.[name]?.variants : undefined;\n\n    return [\n      callOrReturn(styles, theme),\n      processVariants(variants, theme, name, prefix),\n      processVariants(themeVariants, theme, name, prefix),\n    ];\n  };\n\n  return makeClasses<TState>(styleFunction as any);\n};\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}